// Copyright (c) 2019-2020 Alexander Medvednikov. All rights reserved.
// Use of this source code is governed by an MIT license
// that can be found in the LICENSE file.
module compile

import (
	benchmark
	os
	v.builder
	v.pref
	v.util
	strings
)

pub struct V {
pub mut:
        mod_file_cacher     &builder.ModFileCacher // used during lookup for v.mod to support @VROOT
        out_name_c          string // name of the temporary C file
        files               []string // all V files that need to be parsed and compiled
        compiled_dir        string // contains os.real_path() of the dir of the final file beeing compiled, or the dir itself when doing `v .`
        pref                &pref.Preferences // all the preferences and settings extracted to a struct for reusability
        vgen_buf            strings.Builder // temporary buffer for generated V code (.str() etc)
        file_parser_idx     map[string]int // map absolute file path to v.parsers index
        gen_parser_idx      map[string]int
        cached_mods         []string
        module_lookup_paths []string

        v_fmt_all           bool   // << input set by cmd/tools/vfmt.v
        v_fmt_file          string // << file given by the user from cmd/tools/vfmt.v
        v_fmt_file_result   string // >> file with formatted output generated by vlib/compiler/vfmt.v
}

pub fn new_v(pref &pref.Preferences) &V {
        rdir := os.real_path(pref.path)

        mut out_name_c := get_vtmp_filename(pref.out_name, '.tmp.c')
        if pref.is_so {
                out_name_c = get_vtmp_filename(pref.out_name, '.tmp.so.c')
        }

        mut vgen_buf := strings.new_builder(1000)
        vgen_buf.writeln('module vgen\nimport strings')
        compiled_dir:=if os.is_dir(rdir) { rdir } else { os.dir(rdir) }

        return &V{
                mod_file_cacher: builder.new_mod_file_cacher()
                compiled_dir:compiled_dir// if os.is_dir(rdir) { rdir } else { os.dir(rdir) }
                out_name_c: out_name_c
                pref: pref
                vgen_buf: vgen_buf
        }
}


// make v2 from v1
fn (v &V) new_v2() builder.Builder {
        mut b := builder.new_builder(v.pref)
        b = { b|
                os: v.pref.os,
                module_path: pref.default_module_path,
                compiled_dir: v.compiled_dir,
                module_search_paths: v.module_lookup_paths
        }
        return b
}

fn get_vtmp_folder() string {
        vtmp := os.join_path(os.temp_dir(), 'v')
        if !os.is_dir(vtmp) {
                os.mkdir(vtmp) or {
                        panic(err)
                }
        }
        return vtmp
}

fn get_vtmp_filename(base_file_name string, postfix string) string {
        vtmp := get_vtmp_folder()
        return os.real_path(os.join_path(vtmp, os.file_name(os.real_path(base_file_name)) + postfix))
}


pub fn (v mut V) compile_x64() {
        $if !linux {
                println('v -x64 can only generate Linux binaries for now')
                println('You are not on a Linux system, so you will not ' + 'be able to run the resulting executable')
        }
        //v.files << v.v_files_from_dir(os.join_path(v.pref.vlib_path,'builtin','bare'))
        v.files << v.pref.path
        v.set_module_lookup_paths()
        mut b := v.new_v2()
        // move all this logic to v2
        b.build_x64(v.files, v.pref.out_name)
}


pub fn (v mut V) compile2() {
        if os.user_os() != 'windows' && v.pref.ccompiler == 'msvc' {
                verror('Cannot build with msvc on ${os.user_os()}')
        }
        //cgen.genln('// Generated by V')
        //println('compile2()')
        if v.pref.verbosity.is_higher_or_equal(.level_three) {
                println('all .v files before:')
                println(v.files)
        }
        // v1 compiler files
        //v.add_v_files_to_compile()
        //v.files << v.dir
        // v2 compiler
        v.files << v.get_builtin_files()
        v.files << v.get_user_files()
        v.set_module_lookup_paths()
        if v.pref.verbosity.is_higher_or_equal(.level_three) {
                println('all .v files:')
                println(v.files)
        }
        mut b := v.new_v2()
        b.build_c(v.files, v.out_name_c)// v.pref.out_name + '.c')
        v.cc()
}


pub fn compile(command string, args []string) {
	// Construct the V object from command line arguments
	parse_and_output_new_format(args)
	prefs, remaining := parse_arguments(args)
	check_for_common_mistake(args, prefs)
	mut v := new_v(prefs)
	if v.pref.verbosity.is_higher_or_equal(.level_two) {
		println(args)
	}
	mut tmark := benchmark.new_benchmark()
	if v.pref.backend == .x64 {
		v.compile_x64()
	}
	else if v.pref.backend == .experimental {
		v.compile2()
	}
	else {
		//v.compile()
		v.compile2()
	}
	if v.pref.is_stats {
		tmark.stop()
		println('compilation took: ' + tmark.total_duration().str() + 'ms')
	}
	if v.pref.is_test || v.pref.is_run {
		run_compiled_executable_and_exit(v, remaining)
	}
	//v.finalize_compilation()
}

pub fn run_compiled_executable_and_exit(v &V, remaining_args []string) {
	if v.pref.verbosity.is_higher_or_equal(.level_two) {
		println('============ running $v.pref.out_name ============')
	}
	mut cmd := '"${v.pref.out_name}"'
	for i in 1..remaining_args.len {
		// Determine if there are spaces in the parameters
		if remaining_args[i].index_byte(` `) > 0 {
			cmd += ' "' + remaining_args[i] + '"'
		}
		else {
			cmd += ' ' + remaining_args[i]
		}
	}
	if v.pref.verbosity.is_higher_or_equal(.level_two) {
		println('command to run executable: $cmd')
	}
	if v.pref.is_test {
		ret := os.system(cmd)
		if ret != 0 {
			exit(1)
		}
	}
	if v.pref.is_run {
		ret := os.system(cmd)
		// TODO: make the runner wrapping as transparent as possible
		// (i.e. use execve when implemented). For now though, the runner
		// just returns the same exit code as the child process.
		exit(ret)
	}
	exit(0)
}

// 'strings' => 'VROOT/vlib/strings'
// 'installed_mod' => '~/.vmodules/installed_mod'
// 'local_mod' => '/path/to/current/dir/local_mod'
fn (v mut V) set_module_lookup_paths() {
        // Module search order:
        // 0) V test files are very commonly located right inside the folder of the
        // module, which they test. Adding the parent folder of the module folder
        // with the _test.v files, *guarantees* that the tested module can be found
        // without needing to set custom options/flags.
        // 1) search in the *same* directory, as the compiled final v program source
        // (i.e. the . in `v .` or file.v in `v file.v`)
        // 2) search in the modules/ in the same directory.
        // 3) search in the provided paths
        // By default, these are what (3) contains:
        // 3.1) search in vlib/
        // 3.2) search in ~/.vmodules/ (i.e. modules installed with vpm)
        v.module_lookup_paths = []
        if v.pref.is_test {
                v.module_lookup_paths << os.base_dir(v.compiled_dir) // pdir of _test.v
        }
        v.module_lookup_paths << v.compiled_dir
        x := os.join_path(v.compiled_dir, 'modules')
        if v.pref.verbosity.is_higher_or_equal(.level_two) {
                println('x: "$x"')
        }
        v.module_lookup_paths << os.join_path(v.compiled_dir, 'modules')
        v.module_lookup_paths << v.pref.lookup_path
        if v.pref.verbosity.is_higher_or_equal(.level_two) {
                v.log('v.module_lookup_paths') //: $v.module_lookup_paths')
                println(v.module_lookup_paths)
        }
}

pub fn (v &V) get_builtin_files() []string {
        // Lookup for built-in folder in lookup path.
        // Assumption: `builtin/` folder implies usable implementation of builtin
        for location in v.pref.lookup_path {
                if !os.exists(os.join_path(location, 'builtin')) {
                        continue
                }
                if v.pref.is_bare {
                        return v.v_files_from_dir(os.join_path(location, 'builtin', 'bare'))
                }
                $if js {
                        return v.v_files_from_dir(os.join_path(location, 'builtin', 'js'))
                }
                return v.v_files_from_dir(os.join_path(location, 'builtin'))
        }
        // Panic. We couldn't find the folder.
        verror('`builtin/` not included on module lookup path.
Did you forget to add vlib to the path? (Use @vlib for default vlib)')
        panic('Unreachable code reached.')
}


pub fn (v &V) get_user_files() []string {
	mut dir := v.pref.path
	v.log('get_v_files($dir)')
	// Need to store user files separately, because they have to be added after
	// libs, but we dont know	which libs need to be added yet
	mut user_files := []string

    // See cmd/tools/preludes/README.md for more info about what preludes are
	vroot := os.dir(pref.vexe_path())
	preludes_path := os.join_path(vroot, 'cmd', 'tools', 'preludes')
	if v.pref.is_live {
		user_files << os.join_path(preludes_path, 'live_main.v')
	}
	if v.pref.is_solive {
		user_files << os.join_path(preludes_path, 'live_shared.v')
	}
	if v.pref.is_test {
		user_files << os.join_path(preludes_path, 'tests_assertions.v')
	}
	if v.pref.is_test && v.pref.is_stats {
		user_files << os.join_path(preludes_path, 'tests_with_stats.v')
	}

	is_test := dir.ends_with('_test.v')
	mut is_internal_module_test := false
	if is_test {
		tcontent := os.read_file(dir)or{
			panic('$dir does not exist')
		}
		slines := tcontent.trim_space().split_into_lines()
		for sline in slines {
			line := sline.trim_space()
			if line.len > 2 {
				if line[0] == `/` && line[1] == `/` {
					continue
				}
				if line.starts_with('module ') && !line.starts_with('module main') {
					is_internal_module_test = true
					break
				}
			}
		}
	}
	if is_internal_module_test {
		// v volt/slack_test.v: compile all .v files to get the environment
		single_test_v_file := os.real_path(dir)
		if v.pref.verbosity.is_higher_or_equal(.level_two) {
			v.log('> Compiling an internal module _test.v file $single_test_v_file .')
			v.log('> That brings in all other ordinary .v files in the same module too .')
		}
		user_files << single_test_v_file
		dir = os.base_dir(single_test_v_file)
	}
	is_real_file := os.exists(dir) && !os.is_dir(dir)
	if is_real_file && ( dir.ends_with('.v') || dir.ends_with('.vsh') ) {
		single_v_file := dir
		// Just compile one file and get parent dir
		user_files << single_v_file
		if v.pref.verbosity.is_higher_or_equal(.level_two) {
			v.log('> just compile one file: "${single_v_file}"')
		}
	}
	else {
		if v.pref.verbosity.is_higher_or_equal(.level_two) {
			v.log('> add all .v files from directory "${dir}" ...')
		}
		// Add .v files from the directory being compiled
		files := v.v_files_from_dir(dir)
		for file in files {
			user_files << file
		}
	}
	if user_files.len == 0 {
		println('No input .v files')
		exit(1)
	}
	if v.pref.verbosity.is_higher_or_equal(.level_two) {
		v.log('user_files: $user_files')
	}
	return user_files
}
pub fn (v &V) log(s string) {
        if !v.pref.verbosity.is_higher_or_equal(.level_two) {
                return
        }
        println(s)
}


pub fn (v &V) v_files_from_dir(dir string) []string {
        mut res := []string
        if !os.exists(dir) {
                if dir == 'compiler' && os.is_dir('vlib') {
                        println('looks like you are trying to build V with an old command')
                        println('use `v -o v cmd/v` instead of `v -o v compiler`')
                }
                verror("$dir doesn't exist")
        }
        else if !os.is_dir(dir) {
                verror("$dir isn't a directory!")
        }
        mut files := os.ls(dir)or{
                panic(err)
        }
        if v.pref.verbosity.is_higher_or_equal(.level_three) {
                println('v_files_from_dir ("$dir")')
        }
        files.sort()
        for file in files {
                if !file.ends_with('.v') && !file.ends_with('.vh') {
                        continue
                }
                if file.ends_with('_test.v') {
                        continue
                }
                if (file.ends_with('_win.v') || file.ends_with('_windows.v')) && v.pref.os != .windows {
                        continue
                }
                if (file.ends_with('_lin.v') || file.ends_with('_linux.v')) && v.pref.os != .linux {
                        continue
                }
                if (file.ends_with('_mac.v') || file.ends_with('_darwin.v')) && v.pref.os != .mac {
                        continue
                }
                if file.ends_with('_nix.v') && v.pref.os == .windows {
                        continue
                }
                if file.ends_with('_android.v') && v.pref.os != .android {
                        continue
                }
                if file.ends_with('_freebsd.v') && v.pref.os != .freebsd {
                        continue
                }
                if file.ends_with('_solaris.v') && v.pref.os != .solaris {
                        continue
                }
                if file.ends_with('_js.v') && v.pref.os != .js {
                        continue
                }
                if file.ends_with('_c.v') && v.pref.os == .js {
                        continue
                }
                if v.pref.compile_defines_all.len > 0 && file.contains('_d_') {
                        mut allowed := false
                        for cdefine in v.pref.compile_defines {
                                file_postfix := '_d_${cdefine}.v'
                                if file.ends_with(file_postfix) {
                                        allowed = true
                                        break
                                }
                        }
                        if !allowed {
                                continue
                        }
                }
                res << os.join_path(dir, file)
        }
        return res
}

pub fn verror(s string) {
	util.verror('compiler error', s)
}
